# Netty-IM-demo
敲一下别人项目 熟悉一下Netty

#1.归纳框架要点
	spring-boot
	    用约定大于配置的思想快速的完成一个spring项目的创建。
	spring:ioc,aop,动态代理，生命周期，加载过程
	    aop join point 连接点 Pointcut 切入点  Advice 增强 通知 Aspect
	    第一，让 Spring 容器管理对象，要考虑对象默认的 Scope 单例是否适合，对于有状态的类型，单例可能产生内存泄露问题
	    第二，如果要为单例的 Bean 注入 Prototype 的 Bean，绝不是仅仅修改 Scope 属性这么简单。由于单例的 Bean 在容器启动时就会完成一次性初始化。最简单的解决方案是，把 Prototype 的 Bean 设置为通过代理注入，也就是设置 proxyMode 属性为 TARGET_CLASS。
	    第三，如果一组相同类型的 Bean 是有顺序的，需要明确使用 @Order 注解来设置顺序。你可以再回顾下，两个不同优先级切面中 @Before、@After 和 @Around 三种增强的执行顺序，是什么样的。
	    spring实现动态代理两种方式
	        jdk动态代理和CGLIB
	        jdk动态代理只能对实现接口的类进行代理 1、生成的代理类继承了Proxy，由于java是单继承，所以只能实现接口，通过接口实现 
	        CGLIB动态字节注入方式，通过继承实现代理，没有限制。 CGLIB底层：使用字节码处理框架ASM，来转换字节码并生成新的类。 
	spring-事务transactional
	    事务的特性ACID
	    七个事务传播级别
	     PROPAGATION_REQUIRED 如果存在事务，则支持当前事务。没有则开启新的事务。
	     PROPAGATION_SUPPORTS 如果存在事务，支持当前事务。如果没有事务，则非事务执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。
	     PROPAGATION_MANDATORY 如果存在事务，则支持当前事务，如果没有事务则抛出异常。
	     PROPAGATION_REQUIRES_NEW 总是开启事务，如果事务已存在，则将存在事务挂起。
	     PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。
	     PROPAGATION_NEVER 总是非事务的执行，如果存在一个活动事务，则抛出异常。
	     PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按REQUIRED属性执行。
		1，除非特殊配置（比如使用 AspectJ 静态织入实现 AOP），否则只有定义在 public 方法上的 @Transactional 才能生效。原因是，Spring 默认通过动态代理的方式实现 AOP，对目标方法进行增强，private 方法无法代理到，Spring 自然也无法动态增强事务处理逻辑。
		2、必须通过代理过的外部类调用才能生效。
		3、只有异常传播出了标记了 @Transactional 注解的方法，事务才能回滚
		4、默认情况出现RuntimeException非受检异常或者Error的时候Spring才会回滚。
		5.请确认事务传播配置是否符合自己的业务逻辑
	springMvc:路由
	mybatis：三级缓存，类型处理器，多数据源，动态数据源
	mybatisPuls：基础mapper，条件构造器。
	netty，底层原理，demo实现。
	日志框架了解
#2.分布式框架了解
	nignx常用配置，底层原理
	spring-cloud
		Feign 声明式调用
			连接超时时间应该配置的较短一些，因为TCP连接特别快。
			Feign和Ribbon配合使用如何配置超时。
				Feign 配置超时参数的复杂之处在于，Feign 自己有两个超时参数，它使用的负载均衡组件 Ribbon 本身还有相关配置。
				结论一，默认情况下 Feign 的读取超时是 1 秒，如此短的读取超时算是坑点一。
				结论二，也是坑点二，如果要配置 Feign 的读取超时，就必须同时配置连接超时，才能生效。
				结论三，单独的超时可以覆盖全局超时，这符合预期，不算坑。
				结论四，除了可以配置 Feign，也可以配置 Ribbon 组件的参数来修改两个超时时间。这里的坑点三是，参数首字母要大写，和 Feign 的配置不同。
				结论五，同时配置 Feign 和 Ribbon 的超时，以 Feign 为准。
	dubbo了解，demo实现
	消息队列了解，demo实现
	redis缓存。
	    redisTemplate的序列化器可以设置ObjectMapper用于把类信息传入序列化后的数据中。
#3.数据库相关知识
	sql高级语法
	sql性能优化
	    leftjoin
	建表设计
	NoSql
	MyCat了解
#4.java核心知识
	数据结构：map，list，hashMap,并发hashMap
	多线程
		不能使用Executors提供的两种快捷线程池
			1、我们需要根据自己的场景、并发情况来评估线程池的几个核心参数。包括核心线程数、最大线程数、线程回收策略、工作队列、以及拒绝策略。
			一般需要有界队列和可控的线程数。
			2、任何时候都应该为自定义线程指定有意义名称，方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量CPU、线程执行异常等问题，有意义的线程名称可以方便我们排查问题。
			3、确保线程池复用。
			4、根据任务性质来选用不同线程池。特别注意IO绑定任务和CPU绑定任务对于线程池属性偏好。
			5、线程池作为应用程序内部核心组件往往缺乏监控。需注意。
	Lombok 默认实现了set get toString hashCode equals 等方法，但他们的实现逻辑可能与你所期望的有所不同，需要注意。
	使用 BigDecimal 表示和计算浮点数，且务必使用字符串的构造方法来初始化 BigDecimal
	JVM优化
	内存模型
	    java堆 新生代 老年代  存放对象
	    栈 方法区 存放方法 部分对象
	    程序计数器 
	    常量池
	哪些对象可以作为ROOT对象
	虚拟机栈中的引用对象 比如
	方法区中的类静态属性引用对象 比如
	方法区中常量引用对象 比如
	本地方法栈中JNI引用对象 比如
	新生代 10%的复制算法
	年老代 标记清除或者标记整理
	永久代 标记清除或者标记整理
	GC算法
	    GC的三种收集方法
	    标记清除，先标记出全部需不需要清除的对象，让后统一回收被标记的对象。会产生大量的内存碎片。标记和清除的效率都不高。
	    标记整理，标记出全部不需清除的对象，然后将存活的对象向一端移动，然后直接清理掉端边以外的内存。不会产生碎片但整理需要时间。
	    复制算法,使用百分之五十的内存空间作为空闲区，在需要清理时，将可达对象直接复制到空闲区，清除全部的活动区。不会产生内存碎片，但是浪费了一半的内存。
	代理动态代理，cglib
	连接池
		数据库连接池
		Redis连接池
		HTTP连接池
	反射注解泛型
	  反射调用方法不是通过调用时的传参决定的，而是在获取方法的时候通过方法名和参数类型来确定的
	  反射获取类成员getXXX 和 getDeclaredXXX 方法的区别 需要注意
	  泛型因为类型擦除会导致泛型方法T占位符被替换为Object，子类如果使用具体类型覆盖父类实现，编译器会生成桥接方法。这样既满足了子类方法重写父类方法的定义，又满足子类实现的方法有具体的类型。
	  
	文件读写
	    文件读写需要确保字符编码一致
	    FileReader 是以当前机器的默认字符集来读取文件的，如果希望指定字符集的话，需要直接使用 InputStreamReader 和 FileInputStream。
	    使用 Files 类静态方法进行文件操作注意释放文件句柄
	    FileChannel 的 transfreTo 方法进行流的复制。在一些操作系统（比如高版本的 Linux 和 UNIX）上可以实现 DMA（直接内存访问），也就是数据从磁盘经过总线直接发送到目标文件，无需经过内存和 CPU 进行数据中转
	 
	 设计模式
	    模板方法模式
	        通过抽象类实现不同逻辑处理中的相同部分的业务逻辑，将不同业务逻辑部分抽取出来后设置为抽象方法。再由子类继承后实现不同部分的业务逻辑。这样不同子类间不需要实现相同代码。
#5.项目维护
	linux项目维护，常用命令
	docker项目维护日志查询命令，
	Jenkins项目部署
	项目上线需要提供一些健康检测接口
	对外部监控暴露关键资源信息以提高项目可用性，比如线程池队列，连接池等。
	建立应用指标 Metrics 监控。Metrics 可以翻译为度量或者指标，指的是对于一些关键信息以可聚合的、数值的形式做定期统计，并绘制出各种趋势图表。这里的指标监控，包括两个方面：一是，应用内部重要组件的指标监控，比如 JVM 的一些指标、接口的 QPS 等；二是，应用的业务数据的监控，比如电商订单量、游戏在线人数等
	日志 指标 链路追踪
	volatile
#6.底层代码通读
	hashmap
	    hashmap拥有很高的查询效率他会对key的hashCode取模，再直接再node数值中通过模作为下标获取到对应的node，判断该node的key是否是现在的key,如果是则直接返回这个节点，如果不是则会先判断该节点是否是树节点，如果是树节点，则直接用红黑树的查找获取到对应节点，如果不是红黑树则遍历节点的整个链表，
	

	